The recipe for 2.2 is: 
Threat Assessment using ChatGPT and MITRE ATT&CK Framework

Premise:
This recipe will show readers how to use ChatGPT, and also the API the name of a threat, to generate a threat report, details, etc. as well as the MITRE ATT&CK framework TTP mappings and any IoCs associated with the threat, by simply providing a threat, attack, or campaign name. This is useful because it can help cybersecurity professionals do attack vector analysis of their environment, by threat. By adding indicators of compromise (IoCs) to the report, this can begin to extend into threat hunting.

This will build on the skills from Chapter 1: Establishing the system role, engineering an effective prompt that generates formatted output and also table output. We will instruct the reader how to engineer the role of the cybersecurity analyst, and then how to engineer the prompt to get the desired output in ChatGPT. We will then show them how to do it using the API, which can then generate the report as a MS Word file. 



Write the recipe using the following format:

#Recipe Name (Heading 1)

Recipe intro/description. This is also where you can mention how this recipe can be helpful/valuable.

##Getting Ready (Heading 2)

What prerequisites are required before doing this recipe?

##How to do it... (Heading 2)

Provide a lead in sentence or short paragraph to let the reader know what to expect or any other important notes/details prior to beginning the step-by-step instructions.

We will do the ChatGPT version here. Provide step-by-step numbered instructions of how to use the role and prompt in the ChatGPT web UI to get the desired output. 

The following system role will be used:
"You are a professional cyber threat analyst and MITRE ATT&CK Framework expert."

The following user prompt will be used:
"Provide a detailed report about {threat_name}, using the following template (and proper markdown language formatting, headings, bold keywords, tables, etc.):

Threat Name (Heading 1)

Summary (Heading 2)
Short executive summary

Details (Heading 2)
Description and details including history/background, discovery, characteristics and TTPs, known incidents

MITRE ATT&CK TTPs (Heading 2)
Table containing all of the known MITRE ATT&CK TTPs that the {threat_name} attack uses. Include the following collumns: Tactic, Technique ID, Technique Name, Procedure (How {threat_name} uses it)

Indicators of Compromise (Heading 2)
Table containing all of the known indicators of compromise. Include the following collumns: Type, Value, Description"  

##How it works...  (Heading 2)

Explain how/why this recipe works, breaking down each code block if code is used.

##There's more... (Heading 2)

We will do the OpenAI API script version here. Basically do what you did for the "How to do it..." part, but for the OpenAI API version instead of ChatGPT. Use a lead-in sentence or short paragraph and then be sure to relate this back to the ChatGPT version. The Python script will get the name of the threat from user input, and that input will replace {threat_name} in the prompt.

Divide the code up into easily digestible blocks (usually where the comments might be). After the steps, explain how each step/code block works.

If you understand and are ready, I'll provide you with the code that I wrote, for you to write this section.

At the end (or in notes/hints), we should mention that the model can be changed to GPT-4 or whatever in order to get different/better results, and the message parameters can be modified. The prompt can also be adjusted and tweaked in order to get the results the user wants.

Code:

import openai
import os
from docx import Document
from tqdm import tqdm
import threading
import time

# Set up the OpenAI API
openai.api_key = os.getenv("OPENAI_API_KEY")

# Function to generate a report using the OpenAI API
def generate_report(threat_name: str) -> str:

    # Define the conversation messages
    messages = [
        {"role": "system", "content": "You are a professional cyber threat analyst and MITRE ATT&CK Framework expert."},
        {"role": "user", "content": f'Provide a detailed report about {threat_name}, using the following template (and proper markdown language formatting, headings, bold keywords, tables, etc.):\n\n\
        Threat Name (Heading 1)\n\n\
        Summary (Heading 2)\n\
        Short executive summary\n\n\
        Details (Heading 2)\n\
        Description and details including history/background, discovery, characteristics and TTPs, known incidents\n\n\
        MITRE ATT&CK TTPs (Heading 2)\n\
        Table containing all of the known MITRE ATT&CK TTPs that the {threat_name} attack uses. Include the following collumns: Tactic, Technique ID, Technique Name, Procedure (How {threat_name} uses it)\n\n\
        Indicators of Compromise (Heading 2)\n\
        Table containing all of the known indicators of compromise. Include the following collumns: Type, Value, Description\n\n\  '}
    ]

    # Call the OpenAI API
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=messages,
        max_tokens=2048,
        n=1,
        stop=None,
        temperature=0.7,
    )

    # Return the generated text
    return response['choices'][0]['message']['content'].strip()

# Function to convert markdown text to a Word document
def markdown_to_docx(markdown_text: str, output_file: str):
    document = Document()

    # Variables to keep track of the current table
    table = None
    in_table = False

    # Iterate through the lines of the markdown text
    for line in markdown_text.split('\n'):

        # Add headings based on the markdown heading levels
        if line.startswith('# '):
            document.add_heading(line[2:], level=1)
        elif line.startswith('## '):
            document.add_heading(line[3:], level=2)
        elif line.startswith('### '):
            document.add_heading(line[4:], level=3)
        elif line.startswith('#### '):
            document.add_heading(line[5:], level=4)
        # Handle tables in the markdown text
        elif line.startswith('|'):
            row = [cell.strip() for cell in line.split('|')[1:-1]]
            if not in_table:
                in_table = True
                table = document.add_table(rows=1, cols=len(row), style='Table Grid')
                for i, cell in enumerate(row):
                    table.cell(0, i).text = cell
            else:
                if len(row) != len(table.columns):  # If row length doesn't match table, it's a separator
                    continue
                new_row = table.add_row()
                for i, cell in enumerate(row):
                    new_row.cells[i].text = cell
        # Add paragraphs for other text
        else:
            if in_table:
                in_table = False
                table = None
            document.add_paragraph(line)

    # Save the Word document
    document.save(output_file)

# Function to extract tables from the markdown text
def extract_tables(markdown_text: str):
    tables = []
    current_table = []

    # Iterate through the lines of the markdown text
    for line in markdown_text.split('\n'):
        # Check if the line is part of a table
        if line.startswith('|'):
            current_table.append(line)
        # If the table ends, save it to the tables list
        elif current_table:
            tables.append('\n'.join(current_table))
            current_table = []

    return tables

# Function to display elapsed time while waiting for the API call
def display_elapsed_time():
    start_time = time.time()
    while not api_call_completed:
        elapsed_time = time.time() - start_time
        print(f"\rCommunicating with the API - Elapsed time: {elapsed_time:.2f} seconds", end="")
        time.sleep(1)

# Get user input
threat_name = input("Enter the name of a cyber threat: ")

api_call_completed = False
elapsed_time_thread = threading.Thread(target=display_elapsed_time)
elapsed_time_thread.start()

# Handle exceptions during the API call
try:
    # Generate the report using the OpenAI API
    report = generate_report(threat_name)
    api_call_completed = True
    elapsed_time_thread.join()
except Exception as e:
    api_call_completed = True
    elapsed_time_thread.join()
    print(f"\nAn error occurred during the API call: {e}")
    exit()

# Save the report as a Word document
docx_output_file = f"{threat_name}_report.docx"

# Handle exceptions during the report generation
try:
    with tqdm(total=1, desc="Generating report and files") as pbar:
        markdown_to_docx(report, docx_output_file)
    print("\nReport and tables generated successfully!")
except Exception as e:
    print(f"\nAn error occurred during the report generation: {e}")

